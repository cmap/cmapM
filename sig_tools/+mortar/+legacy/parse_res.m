function dat = parse_res(fname)
%PARSE_RES Read .Res Gene expression data format
% DAT = PARSE_RES(FNAME)
% Reads .res file FNAME and returns a structure DAT with the following fields
% GE data matrix
% GN col names
% GD col desc
% SID row names
% SIDESC row desc
% PCALL P calls

% $Author: Rajiv Narayan [narayan@broadinstitute.org]
% $Date: Jul.01.2010 12:01:46 EDT

%CAVEAT: does not handle missing values

% Format Details:
% The first line contains a list of labels identifying the samples
% associated with each of the columns in the remainder of the file. Two
% tabs (\t\t) separate the sample identifier labels because each sample
% contains two data values (an expression value and a
% present/marginal/absent call). 

% Line format:      Description (tab) Accession (tab) (sample 1 name) (tab) (tab) (sample 2 name) (tab) (tab) ... (sample N name) 
% For example:    Description Accession DLBC1_1 DLBC2_1 ... DLBC58_0
% 
% The second line contains a list of sample descriptions. Currently, GSEA
% ignores these descriptions. Our RES file creation tool places the sample
% data file name and scale factors in this row, as shown below. 
% Line format:      (tab) (sample 1 description) (tab) (tab) (sample 2 % description) (tab) (tab) ... (sample N description) 
% Example: MG2000062219AA MG2000062256AA/scale factor=1.2172 ... MG2000062211AA/scale factor=1.1214
% 
% The third line contains a number indicating the number of rows in the
% data table that is contained in the remainder of the file. Note that the
% name and description columns are not included in the number of data
% columns. 
% Line format:      (# of data rows) 
% For example:    7129
% 
% The remainder of the data file contains data for each of the genes. There
% is one row for each gene and two columns for each of the samples. The
% first two fields in the row contain the description and name for each of
% the genes (names and descriptions can contain spaces since fields are
% separated by tabs). The description field is optional but the tab
% following it is not. Each sample has two pieces of data associated with
% it: an expression value and an associated Absent/Marginal/Present (A/M/P)
% call. The A/M/P calls are generated by microarray scanning software (such
% as Affymetrix's GeneChip software) and are an indication of the
% confidence in the measured expression value. Currently, GSEA ignores the
% Absent/Marginal/Present call. 
% Line format:      (gene description) (tab)(gene name) (tab) (sample 1 data) (tab) (sample 1 A/P call) (tab) (sample 2 data) (tab) (sample 2 A/P call) (tab) ... (sample N data) (tab) (sample N A/P call) 
% For example:    AFFX-BioB-5_at (endogenous control) AFFX-BioB-5_at -104 A -152 A ... -44 A 

%try lowmem=1 for memory efficient(slower) parsing
lowmem=0;
%max buffer size (bytes)
maxbuf = 100000;
dat = struct('ge',[],...
    'gn',[],...
    'gd',[],...
    'sid',[],...
    'sidesc',[],...
    'pcall',[]);
try 
    if lowmem
        fid = fopen(fname,'rt');
    else
        fulldat=textread(fname,'%s', 'delimiter', '\n', 'bufsize', maxbuf);
    end
catch
	fprintf ('Error opening %s\n',fname);
end

%read headerlines
%first line
if (lowmem)
    l1=fgetl(fid);
else
    l1 = fulldat{1};
end

%find number of samples
x=strread(l1,'%s','delimiter','\t');

%sample ids
dat.sid={(x{3:2:end})}';
%number of samples
nc=length(dat.sid);

%second line
if (lowmem)
    l2=fgetl(fid);
else
    l2 = fulldat{2};
end
x=strread(l2,'%s','delimiter','\t');
%sample desc
dat.sidesc={(x{2:2:end})}';

%third line
if (lowmem)
    l3=fgetl(fid);
else
    l3 = fulldat{3};
end
%number of rows
nr=str2num(l3);

%read main data

%gene expression data
dat.ge=zeros(nr,nc);
%gene name
dat.gn=cell(nr,1);
%gene description
dat.gd=cell(nr,1);
dat.pcall = cell(nr,nc);

if (lowmem)
	for r=1:nr;
        x=strread(fgetl(fid),'%s','delimiter','\t');
        dat.gd{r}=x{1}; 
        dat.gn{r}=x{2};
        dat.ge(r,:) = str2num(char({x{3:2:end}}))';  
	end
else

	for r=1:nr;
		x=strread(fulldat{r+3},'%s','delimiter','\t');
		dat.gd{r}=x{1}; 
		dat.gn{r}=x{2};
		dat.ge(r,:) = str2num(char({x{3:2:end}}))';
        dat.pcall(r,:) = x(4:2:end)';
	end
end

if (lowmem) fclose(fid); end
