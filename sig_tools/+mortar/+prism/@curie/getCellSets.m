function [gmt_filt, ds, rpt] = getCellSets(varargin)
% getCellSets Extract cell sets from a dataset
%  [gmt_filt, ds, rpt] = getCellSets(varargin)

[args, help_flag] = getArgs(varargin{:});
if ~help_flag
    ds = parse_gctx(args.ds);
    [ncell_line_all, nsamp] = size(ds.mat);
    dbg(1, 'Dataset loaded with %d samples and %d features', nsamp, ncell_line_all);
    % setup labels    
    set_id = get_groupvar(ds.cdesc, ds.chd, args.id_field);
    set_id = upper(validvar(set_id, '-'));
    [set_id, idup] = mkuniq_str(set_id);
    if ~isempty(idup)
        disp(set_id(idup));
        warning('%d duplicate set ids found, deduplicating them by appending a unique integer', length(idup));        
    end
    
    if ~isempty(args.set_prefix)
        set_id = strcat(args.set_prefix, ':', set_id);
    end
    set_desc = get_groupvar(ds.cdesc, ds.chd, args.desc_field);
    if ~isequal(args.member_field, '_id')
        set_member = get_groupvar(ds.rdesc, ds.rhd, args.member_field);
    else
        set_member = ds.rid;
    end
    ds = ds_add_meta(ds, 'column', {'set_id', 'set_desc'}, [set_id, set_desc]);
    ds = ds_add_meta(ds, 'row', {'set_member'}, set_member);
    
    % invert scores if sort order = ascend
    if all(strcmpi(args.sort_order, 'ascend'))
        is_score_inverted = true;
        ds.mat = -ds.mat;        
        dbg(1, 'Ascend order specified inverting scores');
    else
        is_score_inverted = false;
    end
    
    % compute threshold on all cell lines
    if ~isnan(args.custom_threshold)
        score_cutoff = args.custom_threshold;
        if is_score_inverted
            score_cutoff = -score_cutoff;
        end
        dbg(1, 'Using custom threshold of %2.2f', score_cutoff);        
    else
        score_cutoff = prctile(ds.mat(:), args.prctile_threshold);
        dbg(1, '%2.2f percentile cutoff is : %2.2f', args.prctile_threshold, score_cutoff)
    end
    
    if ~isempty(args.feature_space)
        ds = ds_slice(ds, 'rid', args.feature_space, 'ignore_missing', true);
    end
    
    if ~isempty(args.feature_filter)
        ds = ds_slice(ds, 'row_filter', args.feature_filter, 'ignore_missing', true);
    end
    
    ncell_line = length(ds.rid);
    dbg(1, 'Retained %d / %d cell lines matching feature space', ncell_line, ncell_line_all);
    assert(ncell_line > 0, 'No cell lines remain after filtering');
    
    % apply thresholds to filtered cell lines
    is_hit = ds.mat >= score_cutoff;
    ds_outlier = ds_get_hits(ds, is_hit);
         
    gmt_outlier = tbl2gmt(ds_outlier,...
        'group_field', 'col_set_id',...
        'desc_field', 'col_set_desc',...
        'member_field', 'row_set_member');
        
    % apply set size filters
    max_set_size = round(args.max_pct_lines * ncell_line/100);
    
    set_size = [gmt_outlier.len]';
    has_ok_size = (set_size >= args.min_set_size &...
                   set_size < max_set_size);
    gmt_filt = gmt_outlier(has_ok_size);
    dbg(1, '%d / %d sets pass the size filter of %d - %d',...
        length(gmt_filt), nsamp, args.min_set_size, max_set_size);
    
    if is_score_inverted
        signed_score_cutoff = -score_cutoff;
        ds.mat = -ds.mat;
    else
        signed_score_cutoff = score_cutoff;
    end
    
    rpt = struct('num_set', length(gmt_filt),...
                 'num_sample', nsamp,...
                 'num_cell_line', ncell_line,...
                 'num_cell_line_all', ncell_line_all,...
                 'score_cutoff', signed_score_cutoff,...
                 'is_score_inverted', is_score_inverted,...
                 'percentile_threshold', args.prctile_threshold,...                 
                 'min_set_size', args.min_set_size,...
                 'max_set_size', max_set_size);
end

end

function [args, help_flag] = getArgs(varargin)
pnames = {'ds';...
    '--feature_space';...
    '--feature_filter';...
    '--prctile_threshold';...
    '--custom_threshold';...
    '--sort_order';...
    '--max_pct_lines';...
    '--min_set_size';...
    '--id_field';...
    '--desc_field';...
    '--member_field';...
    '--set_prefix';...
    };

dflts = {'';...
    '';...
    '';...
    90;...
    nan;...
    'descend';...
    50;...
    3;...
    'pert_iname';...
    'pert_id';...
    '_id';...
    ''};

help_str = {'Dataset with viability scores e.g. AUC or IC50';...
    'Subset of features (row ids) as a GRP file to define subsets';...
    'Filter as a GMT/GMX file specifying features to keep';...
    'Percentile cutoff for selecting cell lines';...
    'Custom cutoff for selecting cell lines, (alternative to prctile threshold)';...
    'Sort order of the dataset, by default the scores are sorted in descending order. If ascend is specified, the ordering is inverted prior to applying the threshold';...
    'Maximum percent of cell lines in a set. Cell sets with more than the specified number of lines are excluded from the result';...
    'Minimum number of cell lines in a cell set. Cell sets with fewer cell lines are excluded';...
    'Indentifier field(s) of a cell set, must exist as a Column metadata field in DS';...
    'Descriptor field(s), of a cell set descriptor, must exist as a Column metadata field in DS';...
    'Entry field of a cell set, must exist as a Row metadata field in DS';...
    'Prefix string added to all set names'};

config = struct('name', pnames,...
    'default', dflts,...
    'help', help_str);

opt = struct('prog', mfilename,...
        'desc', 'Compute cell line sets from a dataset',...
        'undef_action', 'error');
  
[args, help_flag] = mortar.common.ArgParse.getArgs(config, opt, varargin{:});

end