function outFile = collateDatasets(fileList, outFile, varargin)
% collateDatasets Collate a list of datasets to disk                             
% collateFiles(fileList, outFile, varargin)
% See collateFiles('--help')
pnames = {'--rid';...
    '--cid';...
    '--row_space';...
    '--exclude_rid';...
    '--exclude_cid';...
    '--block_size';...
    '--use_compression';...
    '--skip_annot';...
    '--merge_partial';...
    '--missing_value';...
    '--verbose'
};
dflts = {'';...
    '';...
    '';...
    false;...
    false;...
    25;...
    false;...
    false;...
    false;...
    nan;...
    true;...
    };
desc = {'Row ids to include';...
        'Column ids to include';...
        'Row space to include';...
        'Exclude features or rows specified by rid or row_space if true';...
        'Exclude samples or columns specified by cid if true';...
        'Number of files to read before writing output to disk';...
        'Use compression when saving in GCTX format';...
        'Skip annotations if true';...
        'Adjust dataset for missing ids';...
        'Missing value if pad_missing is true';...
        'Print debugging messages';...
    };
config = struct('name', pnames, 'default', dflts, 'help', desc); 
opt = struct('prog', mfilename, 'desc', 'Collate datasets');
args = mortar.common.ArgParse.getArgs(config, opt, varargin{:});

fileList = parse_grp(fileList);
nfile = numel(fileList);
if nfile>0
    nblock = ceil(nfile / args.block_size);
    ncol = 0;
    if ~isempty(args.rid)
        rid = parse_grp(args.rid);
    elseif ~isempty(args.row_space)
        rid = mortar.common.Spaces.probe(args.row_space).asCell;
    else
        rid = '';
    end
    
    if ~isempty(args.cid)
        cid = parse_grp(args.cid);
    else
        cid = '';
    end
    
    dbg(args.verbose, 'Collating %d folders in %d blocks...', nfile, nblock);
    if args.use_compression
        compression = 'gzip';
    else
        compression = 'none';
    end    
    for ii=1:nblock
        dbg(args.verbose, 'Block: %d/%d', ii, nblock);
        st = (ii-1)*args.block_size + 1;
        stp = min(st + args.block_size - 1, nfile);
        outds = merge_profile(fileList(st:stp),...
            'skip_annot', args.skip_annot,...
            'rid', rid, 'exclude_rid', args.exclude_rid,...
            'merge_partial', args.merge_partial,...
            'missing_value', args.missing_value);
        this_cid = intersect_ord(cid, outds.cid);
        outds = ds_slice(outds, 'cid', this_cid,...
                        'exclude_cid', args.exclude_cid,...
                        'isverbose', args.verbose);
        this_ncol = length(outds.cid);
        if this_ncol>0
            ncol = ncol + this_ncol;
            mkgctx(outFile, outds,...
                'insert', true,...
                'appenddim', false,...
                'compression', compression,...
                'compression_level', 6);
        else
            dbg(1, 'Skipping empty block');
        end
    end    
    dbg(args.verbose, 'Collated %d columns', ncol);
else
    dbg(args.verbose, 'No valid folders found, skipping');
end
end