function [up, dn] = get_genesets(ds, ngene, sortorder, varargin)
% GET_GENESETS Create genesets from a score matrix.
%   [UP, DN] = GET_GENESETS(DS, N, SORTORDER) Returns the top N and
%   bottom N genesets for the score dataset DS sorted according to
%   SORTORDER. SORTORDER can be 'descend' or 'ascend'. UP and DN are
%   structures with length equal to the number of columns in DS. 
%
%   Each row in the structure has the the following fields:
%   hd : String header, same as the column id in DS with either '_UP' or
%       '_DN' appended.
%   desc :  String descriptor. Set to ''.
%   entry : Cell array of N row identifiers in DS.
%
%   [UP, DN] = GET_GENESETS(DS, N, SORTORDER, PARAM1, VALUE1) Specify
%   optional parameters:
%   'es_tail'   : String, specifies which tail to return.
%                 Can be {'both', 'up', 'down'}. Default is 'both'
%   'id_field'  : String, specifies an alternate metadata field to use for
%                 selecting features instead of ids. Default is '_id'
%   'suffix'    : String, Append string to each set name. Default is none.
%   'dim'       : String, Dimension of matrix to operate on. 
%                 Can be {'column', 'row'}. Default is to operate on
%                 'column' and return row-ids as sets
%   'enforce_set_size' : Boolean, Assert if set sizes match N exactly.
%                 A set size of less than N can result in cases where an 
%                 alternate id_field is specified and there are duplicate 
%                 entries. Set to false to disable this constraint. Default
%                 is true.

pnames = {'es_tail', 'suffix', 'id_field', 'dim', 'enforce_set_size'};
dflts = {'both', '', '_id', 'column', true};
args = parse_args(pnames, dflts, varargin{:});

ds = parse_gctx(ds);
[dim_str, dim_val] = get_dim2d(args.dim);
if isequal(dim_str, 'row')
    ds = transpose_gct(ds);
end

[~, nc] = size(ds.mat);

[~, srtidx] = sort(ds.mat, sortorder);

if all(ismember({'pert_desc', 'pert_type'}, ds.chd))
    desc = strcat('desc:', ds.cdesc(:, ds.cdict('pert_desc')));
    desc = strcat(desc, ' type:', ds.cdesc(:, ds.cdict('pert_type')));
    if isKey(ds.cdict, 'distil_nsample')
        desc = strcat(desc, ' n:', num2cellstr(cell2mat(ds.cdesc(:, ds.cdict('distil_nsample')))));
    end
    if isKey(ds.cdict, 'islmark')
        desc = strcat(desc, ' lmark:', num2cellstr(cell2mat(ds.cdesc(:, ds.cdict('islmark')))));
    end
else
    desc = cell(nc, 1);
    [desc(:)] = {''};
end

if isempty(args.suffix)
    set_name = ds.cid;
else
    set_name = strcat(ds.cid, '_', args.suffix);
end

ids = ds_get_meta(ds,'row', args.id_field);
% check for duplicate ids
dup_ids = duplicates(ids);
has_dup_ids = ~isempty(dup_ids);
if has_dup_ids && args.enforce_set_size
    error(['ID field %s has %d duplicate entries listed above. ',...
           'Specify enforce_set_size to adjust this constraint'],...
           args.id_field, length(dup_ids));
end

up = struct('head', strcat(set_name, '_UP'),...
            'desc', desc,...
            'entry','',...
            'len', ngene);

dn = struct('head', strcat(set_name, '_DN'),...
            'desc', desc,...
            'entry','',...
            'len', ngene);

for ii=1:nc
    switch(lower(args.es_tail))
        case 'both'
            up(ii).entry = get_ids(ids, srtidx(1:ngene, ii), has_dup_ids);
            dn(ii).entry = get_ids(ids, srtidx(end-ngene+1:end, ii), has_dup_ids);
        case 'up'
            up(ii).entry = get_ids(ids, srtidx(1:ngene, ii), has_dup_ids);            
        case 'down'
            dn(ii).entry = get_ids(ids, srtidx(end-ngene+1:end, ii), has_dup_ids);
        otherwise
            error('Invalid es_tail, expected {both, up, down}, got %s', es_tail);
    end
end

if isequal(args.es_tail, 'up')
    dn = struct([]);
end

if isequal(args.es_tail, 'down')
    up = struct([]);
end
end

function res = get_ids(ids, idx, make_unique)
    res = ids(idx);
    if make_unique
        res = unique(res, 'stable');
    end
end