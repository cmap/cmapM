function rnk = ds_group_rank(varargin)
% ds_group_rank Rank dataset within specified groups
% R = ds_group_rank('ds', DS)
% R = ds_group_rank('ds', DS, 'param', value,...)
% Type ds_group_rank('help') for details

[args, help_flag] = getArgs(varargin{:});

if ~help_flag
    assert(~isempty(args.group),  'Grouping variable(s) not specified');
   
    [dim_str, dim_val] = get_dim2d(args.dim);
    
    args.ds = parse_gctx(args.ds);
    rnk = args.ds;
    rnk.mat = nan(size(rnk.mat));
    switch dim_str
        case 'column'
            [gpv, gpn, gpi,~, gpsz] = get_groupvar(args.ds.rdesc, args.ds.rhd, args.group);
            ngp = length(gpn);
            dbg(1, 'Ranking rows of input for %d groups', ngp);
            for ii=1:ngp                
                this_gp = gpi == ii;
                dbg(1, '%d/%d %s (n=%d)', ii, ngp, gpn{ii}, nnz(this_gp))
                rnk.mat(this_gp, :) = rankorder(args.ds.mat(this_gp, :),...
                    'dim', 'column',...
                    'direc', args.direc,...
                    'fixties', args.fixties,...
                    'as_fraction', args.as_fraction,...
                    'as_percentile', args.as_percentile,...
                    'zeroindex', args.zeroindex);
            end
            
        case 'row'
            [gpv, gpn, gpi,~, gpsz] = get_groupvar(args.ds.cdesc, args.ds.chd, args.group);
            ngp = length(gpn);
            dbg(1, 'Ranking columns of input for %d groups', ngp);
            for ii=1:ngp
                this_gp = gpi == ii;
                dbg(1, '%d/%d %s (n=%d)', ii, ngp, gpn{ii}, nnz(this_gp))
                rnk.mat(:, this_gp) = rankorder(args.ds.mat(:, this_gp),...
                    'dim', 'row',...
                    'direc', args.direc,...
                    'fixties', args.fixties,...
                    'as_fraction', args.as_fraction,...
                    'as_percentile', args.as_percentile,...
                    'zeroindex', args.zeroindex);
            end
    end
else
    rnk = [];
end
end
function [args, help_flag] = getArgs(varargin)
pnames = {'--ds',...
          '--dim',....
          '--direc',...
          '--group',...
          '--zeroindex',...
          '--fixties',...
          '--as_fraction',...
          '--as_percentile'};
      
dflts = {'',...
         'column',...
         'descend',...
         {},...
         false,...
         true,...
         false,...
         false};     
     
help_str = {'Input dataset as GCT structure',...
            'Select a dimension along which to sort. Sorts each column if 1 or ''column'' OR each row if 2 or ''row''' ,...
            'Select the direction of the sort ''ascend'' or ''descend''',...
            'cell array, Metadata fields to use to construct groups',...
            'Ranks are zero-indexed if true',...
            'Adjust for ties if true',...
            'Returns ranks as a fraction if true',...
            'Returns ranks as a percentile of total if true'};
config = struct('name', pnames, 'default', dflts, 'help', help_str);
opt = struct('prog', mfilename, 'desc', '');
[args, help_flag] = mortar.common.ArgParse.getArgs(config, opt, varargin{:});
end