function varargout = gctextract_tool(varargin)
% GCTEXTRACT_TOOL Extract a subset of data from a GCT file.
%   GCTEXTRACT_TOOL(FILENAME, 'param1', value1, ...) 
%   Extracts a subset of data from FILENAME. The following parameters are
%   supported:
%       Parameter   Value
%       'rid'       List of row ids to extract, specified as a GRP file.
%                   Default is all row ids.
%       'cid'       List of column ids to extract, specified as a GRP file.
%                   Default is all column ids.
%       'rdesc'     Row descriptors, specified as a TBL file. Default is to
%                   keep descriptors from the source file.
%       'cdesc'     Column descriptors to include in the extracted dataset.
%                   Specified as a TBL file. Default is to keep
%                   descriptors from the source file.
%       'exclude_rid'   Exclude 'rid' if true. Default is false
%       'exclude_cid'   Exclude 'cid' if true. Default is false
%       'key_rdesc' Key field in rdesc that matches the row id of the
%                   source file. Default is 'id'
%       'key_cdesc' Key field in cdesc that matches the column id of the
%                   source file. Default is 'id'
%       'out'       Ouput folder. Default is PWD.
%       'mkdir'     Create a subfolder for the output file. Default is
%                   true.
%       'transpose' Transpose the data matrix. Default is false.
%       'xform'     Transform the data matrix. Default is 'none'.
%                   Valid options are:
%                   {'abs', 'log2', 'pow2', 'exp', 'log', 'zscore', 'none'}

toolName = mfilename;

help_flag = false;
try
args = get_args(varargin{:});
catch ME
    if strcmp(ME.identifier, 'mortar:common:ArgParse:HelpRequest')
        help_flag = true;
    else
        error('%s %s', ME.identifier, ME.message);
    end
end

if ~help_flag
    isnout = nargout>0;
    if ~isnout
        print_args(toolName, 1, args);
    end
    
    if ischar(args.in) || isstruct(args.in)
        ds = parse_gctx(args.in);
    else
        error ('gctextract_tool:InvalidInput', 'Infile is not valid')
    end
    
    % create subset
    ds = ds_slice(ds,...
        '--rid', args.rid,...
        '--ridx', args.ridx,...
        '--cid', args.cid,...
        '--cidx', args.cidx,...
        '--exclude_rid', args.exclude_rid,...
        '--exclude_cid', args.exclude_cid,...
        '--ignore_missing', args.ignore_missing,...
        '--isverbose', args.verbose);

    if isfileexist(args.cdesc)
        ds = annotate_ds(ds, args.cdesc, 'dim', 'column', 'keyfield', args.key_cdesc);
    end
    
    if isfileexist(args.rdesc)
        ds = annotate_ds(ds, args.rdesc, 'dim', 'row', 'keyfield', args.key_rdesc);
    end
    % transform if required
    ds.mat = do_xform(ds.mat, args.xform, 'verbose', ~isnout);
    
    if args.transpose
        ds = transpose_gct(ds);
    end
    %% analysis ouput folders
    if ~isnout
        if args.mkdir
            wkdir = mkworkfolder(args.out, toolName);
        else
            wkdir = args.out;
        end
        fprintf ('Saving analysis to %s\n', wkdir);
        
        % save parameters
        print_args(toolName, sprintf('%s_params.txt',toolName), args);
        
        if isfield(ds, 'src')
            infile = ds.src;
        else
            infile = 'ds.gct';
        end
        [~,f,e] = fileparts(infile);
        if args.use_gctx
            gctwriter=@mkgctx;
        else
            gctwriter=@mkgct;    
        end
        gctwriter(fullfile(wkdir,[f,e]), ds, 'precision', args.precision);
    else
        varargout(1) = {ds};
    end

end

end

function args = get_args(varargin)

valid_xform = {'zscore','log2','abs','pow2','exp','log','none'};

name = {'in',...
    '--rid',...
    '--cid',...
    '--ridx',...
    '--cidx',...
    '--out', ...
    '--rdesc',...
    '--cdesc',...
    '--key_rdesc',...
    '--key_cdesc',...
    '--xform',...
    '--transpose',...
    '--mkdir',...
    '--ignore_missing',...
    '--verbose',...
    '--exclude_rid',...
    '--exclude_cid',...
    '--precision',...
    '---use_gctx'};

dflts =  {'',...
          '',...
          '',...
          [],...
          [],...          
          pwd,...
          '',...
          '',...
          'id',...
          'id',...
          'none',...
          false,...
          true,...
          true,...
          false,...
          false,...
          false,...
          4,...
          true};

help_str = {'Input file in GCT or GCTX format',...
          'List of row ids to extract, specified as a GRP file. Default is all row ids.',...
          'List of column ids to extract, specified as a GRP file. Default is all column ids.',...
          'List of row indices to extract, specified as a GRP file. Default is all row indices.',...
          'List of column indices to extract, specified as a GRP file. Default is all column indices.',...
          'Ouput folder. Default is PWD.',...
          'Row descriptors, specified as a TBL file. Default is to keep descriptors from the source file.',...
          'Column descriptors to include in the extracted dataset. Specified as a TBL file. Default is to keep descriptors from the source file.',...
          'Key field in rdesc that matches the row id of the source file. Default is id',...
          'Key field in cdesc that matches the column id of the source file. Default is id',...
          'Transform the data matrix. Default is none. Valid options are: {abs, log2, pow2, exp, log, zscore, none}',...
          'Transpose the data matrix. Default is false.',...
          'Create a subfolder for the output file. Default is true.',...
          'Ignore missing ids. Default is false',...
          'Enable debugging information. Default is false.',...
          'Exclude rid if true. Default is false',...
          'Exclude cid if true. Default is false',...
          'Numeric precision used to save dataset. Default is 4',...
          'Save in GCTX format if true else use GCT format. Default True.'};

param = struct('name', name, 'default', dflts, 'help', help_str);
parser = mortar.common.ArgParse('gctextract_tool', 'Extract a subset of values from a GCT(X) file.');
parser.add(param);
try
    args = parser.parse(varargin{:});
catch ME
    if strcmp(ME.identifier, 'mortar:common:ArgParse:HelpRequest')
        rethrow(ME);
    else
        error('%s %s', ME.identifier, ME.message);
    end
end

%sanity checks
assert(isvalidstr(args.xform, valid_xform), 'Invalid transform: %s\n', args.xform);
end


